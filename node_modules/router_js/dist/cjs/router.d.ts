import RouteRecognizer, { Delegate, MatchCallback } from 'route-recognizer';
import { Promise } from 'rsvp';
import { Dict, Maybe } from './core';
import HandlerInfo, { IHandler } from './handler-info';
import { Transition } from './transition';
import { TransitionIntent } from './transition-intent';
import TransitionState from './transition-state';
import { ChangeList } from './utils';
export interface SerializerFunc {
    (model: Dict<unknown>, params: Dict<unknown>): unknown;
}
export interface GetSerializerFunc {
    (name: string): SerializerFunc;
}
export interface GetHandlerFunc {
    (name: string): IHandler | Promise<IHandler>;
}
export interface DidTransitionFunc {
    (handlerInfos: HandlerInfo[]): void;
}
export interface RouterArgs {
    getHandler: GetHandlerFunc;
    getSerializer: GetSerializerFunc;
    updateURL(url: string): void;
    delegate: Delegate;
    willTransition?(oldHandlerInfos: HandlerInfo[], newHandlerInfos: HandlerInfo[], transition: Transition): void;
    didTransition?: DidTransitionFunc;
    replaceURL?(url: string): void;
    triggerEvent?(handlerInfos: HandlerInfo[], ignoreFailure: boolean, args: unknown[]): void;
    log?(message: string): void;
}
declare class Router {
    getHandler: GetHandlerFunc;
    getSerializer: GetSerializerFunc;
    updateURL: (url: string) => void;
    delegate: Delegate;
    willTransition?: (oldHandlerInfos: HandlerInfo[], newHandlerInfos: HandlerInfo[], transition: Transition) => void;
    didTransition?: DidTransitionFunc;
    replaceURL?: (url: string) => void;
    triggerEvent?: (handlerInfos: HandlerInfo[], ignoreFailure: boolean, args: unknown[]) => void;
    log?: (message: string) => void;
    state?: TransitionState;
    oldState: Maybe<TransitionState>;
    activeTransition?: Transition;
    currentHandlerInfos?: HandlerInfo[];
    _changedQueryParams?: Dict<unknown>;
    currentSequence: number;
    recognizer: RouteRecognizer;
    dslCallBacks: unknown[];
    constructor(options: RouterArgs);
    /**
      The main entry point into the router. The API is essentially
      the same as the `map` method in `route-recognizer`.
  
      This method extracts the String handler at the last `.to()`
      call and uses it as the name of the whole route.
  
      @param {Function} callback
    */
    map(callback: MatchCallback): void;
    hasRoute(route: string): boolean;
    queryParamsTransition(changelist: ChangeList, wasTransitioning: boolean, oldState: TransitionState, newState: TransitionState): Transition;
    transitionByIntent(intent: TransitionIntent, isIntermediate: boolean): any;
    /**
      Clears the current and target route handlers and triggers exit
      on each of them starting at the leaf and traversing up through
      its ancestors.
    */
    reset(): void;
    /**
      let handler = handlerInfo.handler;
      The entry point for handling a change to the URL (usually
      via the back and forward button).
  
      Returns an Array of handlers and the parameters associated
      with those parameters.
  
      @param {String} url a URL to process
  
      @return {Array} an Array of `[handler, parameter]` tuples
    */
    handleURL(url: string): any;
    /**
      Transition into the specified named route.
  
      If necessary, trigger the exit callback on any handlers
      that are no longer represented by the target route.
  
      @param {String} name the name of the route
    */
    transitionTo(name: string | {
        queryParams: Dict<unknown>;
    }, ...contexts: any[]): any;
    intermediateTransitionTo(name: string, ...args: any[]): any;
    refresh(pivotHandler?: IHandler): any;
    /**
      Identical to `transitionTo` except that the current URL will be replaced
      if possible.
  
      This method is intended primarily for use with `replaceState`.
  
      @param {String} name the name of the route
    */
    replaceWith(name: string): any;
    /**
      Take a named route and context objects and generate a
      URL.
  
      @param {String} name the name of the route to generate
        a URL for
      @param {...Object} objects a list of objects to serialize
  
      @return {String} a URL
    */
    generate(handlerName: string, ...args: any[]): string;
    applyIntent(handlerName: string, contexts: Dict<unknown>[]): TransitionState;
    isActiveIntent(handlerName: string, contexts: any[], queryParams?: Dict<unknown>, _state?: TransitionState): boolean;
    isActive(handlerName: string, ...args: unknown[]): boolean;
    trigger(name: string, ...args: any[]): void;
}
export interface HandlerPartition {
    updatedContext: HandlerInfo[];
    exited: HandlerInfo[];
    entered: HandlerInfo[];
    unchanged: HandlerInfo[];
    reset: HandlerInfo[];
}
export default Router;
