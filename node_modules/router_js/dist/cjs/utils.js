'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isPromise = isPromise;
exports.merge = merge;
exports.extractQueryParams = extractQueryParams;
exports.coerceQueryParamsToString = coerceQueryParamsToString;
exports.log = log;
exports.isParam = isParam;
exports.forEach = forEach;
exports.trigger = trigger;
exports.getChangelist = getChangelist;
exports.promiseLabel = promiseLabel;
var slice = exports.slice = Array.prototype.slice;
var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
  Determines if an object is Promise by checking if it is "thenable".
**/
function isPromise(p) {
    return p !== null && typeof p === 'object' && typeof p.then === 'function';
}
function merge(hash, other) {
    for (var prop in other) {
        if (hasOwnProperty.call(other, prop)) {
            hash[prop] = other[prop];
        }
    }
}
/**
  @private

  Extracts query params from the end of an array
**/
function extractQueryParams(array) {
    var len = array && array.length,
        head = void 0,
        queryParams = void 0;
    if (len && len > 0) {
        var obj = array[len - 1];
        if (isQueryParams(obj)) {
            queryParams = obj.queryParams;
            head = slice.call(array, 0, len - 1);
            return [head, queryParams];
        }
    }
    return [array, null];
}
function isQueryParams(obj) {
    return obj && hasOwnProperty.call(obj, 'queryParams');
}
/**
  @private

  Coerces query param properties and array elements into strings.
**/
function coerceQueryParamsToString(queryParams) {
    for (var key in queryParams) {
        var val = queryParams[key];
        if (typeof val === 'number') {
            queryParams[key] = '' + val;
        } else if (Array.isArray(val)) {
            for (var i = 0, l = val.length; i < l; i++) {
                val[i] = '' + val[i];
            }
        }
    }
}
/**
  @private
 */
function log(router) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
    }

    if (!router.log) {
        return;
    }
    if (arguments.length === 2) {
        var sequence = args[0],
            msg = args[1];

        router.log('Transition #' + sequence + ': ' + msg);
    } else {
        var _msg = args[0];

        router.log(_msg);
    }
}
function isParam(object) {
    return typeof object === 'string' || object instanceof String || typeof object === 'number' || object instanceof Number;
}
function forEach(array, callback) {
    for (var i = 0, l = array.length; i < l && callback(array[i]) !== false; i++) {
        // empty intentionally
    }
}
function trigger(router, handlerInfos, ignoreFailure, name) {
    for (var _len2 = arguments.length, args = Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {
        args[_key2 - 4] = arguments[_key2];
    }

    if (router.triggerEvent) {
        router.triggerEvent(handlerInfos, ignoreFailure, [name].concat(args));
        return;
    }
    if (!handlerInfos) {
        if (ignoreFailure) {
            return;
        }
        throw new Error("Could not trigger event '" + name + "'. There are no active handlers");
    }
    var eventWasHandled = false;
    for (var i = handlerInfos.length - 1; i >= 0; i--) {
        var currentHandlerInfo = handlerInfos[i],
            currentHandler = currentHandlerInfo.handler;
        // If there is no handler, it means the handler hasn't resolved yet which
        // means that we should trigger the event later when the handler is available
        if (!currentHandler) {
            currentHandlerInfo.handlerPromise.then(function (resolvedHandler) {
                resolvedHandler.events[name].apply(resolvedHandler, args);
            });
            continue;
        }
        if (currentHandler.events && currentHandler.events[name]) {
            if (currentHandler.events[name].apply(currentHandler, args) === true) {
                eventWasHandled = true;
            } else {
                return;
            }
        }
    }
    // In the case that we got an UnrecognizedURLError as an event with no handler,
    // let it bubble up
    if (name === 'error' && args[0].name === 'UnrecognizedURLError') {
        throw args[0];
    } else if (!eventWasHandled && !ignoreFailure) {
        throw new Error("Nothing handled the event '" + name + "'.");
    }
}
function getChangelist(oldObject, newObject) {
    var key = void 0;
    var results = {
        all: {},
        changed: {},
        removed: {}
    };
    merge(results.all, newObject);
    var didChange = false;
    coerceQueryParamsToString(oldObject);
    coerceQueryParamsToString(newObject);
    // Calculate removals
    for (key in oldObject) {
        if (hasOwnProperty.call(oldObject, key)) {
            if (!hasOwnProperty.call(newObject, key)) {
                didChange = true;
                results.removed[key] = oldObject[key];
            }
        }
    }
    // Calculate changes
    for (key in newObject) {
        if (hasOwnProperty.call(newObject, key)) {
            var oldElement = oldObject[key];
            var newElement = newObject[key];
            if (isArray(oldElement) && isArray(newElement)) {
                if (oldElement.length !== newElement.length) {
                    results.changed[key] = newObject[key];
                    didChange = true;
                } else {
                    for (var i = 0, l = oldElement.length; i < l; i++) {
                        if (oldElement[i] !== newElement[i]) {
                            results.changed[key] = newObject[key];
                            didChange = true;
                        }
                    }
                }
            } else if (oldObject[key] !== newObject[key]) {
                results.changed[key] = newObject[key];
                didChange = true;
            }
        }
    }
    return didChange ? results : undefined;
}
function isArray(obj) {
    return Array.isArray(obj);
}
function promiseLabel(label) {
    return 'Router: ' + label;
}
// export function callHook(obj: any, _hookName: string, arg1?: unknown, arg2?: unknown) {
//   let hookName = resolveHook(obj, _hookName);
//   return hookName && obj[hookName].call(obj, arg1, arg2);
// }
//# sourceMappingURL=utils.js.map