import { Promise } from 'rsvp';
import { Dict } from './core';
import { GetHandlerFunc, SerializerFunc } from './router';
import { Transition } from './transition';
interface IModel {
    id?: string | number;
}
export declare const noopGetHandler: () => Promise<IHandler>;
export declare const DEFAULT_HANDLER: IHandler;
export interface HandlerInfoArgs {
    name: string;
    handler?: any;
}
export interface HandlerHooks {
    model?(params: Dict<unknown>, transition: Transition): Promise<Dict<unknown> | null | undefined> | undefined | Dict<unknown>;
    deserialize?(params: Dict<unknown>, transition: Transition): Dict<unknown>;
    serialize?(model: Dict<unknown>, params: string[]): Dict<unknown>;
    beforeModel?(transition: Transition): Promise<Dict<unknown> | null | undefined> | undefined;
    afterModel?(resolvedModel: Dict<unknown>, transition: Transition): Promise<Dict<unknown> | null | undefined>;
    setup?(context: Dict<unknown>, transition: Transition): void;
    enter?(transition: Transition): void;
    exit?(transition?: Transition): void;
    reset?(wasReset: boolean, transition?: Transition): void;
    contextDidChange?(): void;
    redirect?(context: Dict<unknown>, transition: Transition): void;
    _model?(params: Dict<unknown>, transition: Transition): Promise<Dict<unknown> | null | undefined> | undefined | Dict<unknown>;
    _deserialize?(params: Dict<unknown>, transition: Transition): Dict<unknown>;
    _serialize?(model: Dict<unknown>, params: string[]): Dict<unknown>;
    _beforeModel?(transition: Transition): Promise<Dict<unknown> | null | undefined> | undefined;
    _afterModel?(resolvedModel: Dict<unknown>, transition: Transition): Promise<Dict<unknown> | null | undefined>;
    _setup?(context: Dict<unknown>, transition: Transition): void;
    _enter?(transition: Transition): void;
    _exit?(transition?: Transition): void;
    _reset?(wasReset: boolean, transition?: Transition): void;
    _contextDidChange?(): void;
    _redirect?(context: Dict<unknown>, transition: Transition): void;
}
export interface IHandler extends HandlerHooks {
    inaccessibleByURL?: boolean;
    _handlerName: string;
    context: unknown;
    names: string[];
    name?: string;
    handler: string;
    events?: Dict<Function>;
}
export declare type Continuation = () => PromiseLike<boolean> | boolean;
export interface IResolvedModel {
    [key: string]: unknown;
}
export default abstract class HandlerInfo {
    private _handlerPromise?;
    private _handler?;
    name: string;
    params: Dict<unknown>;
    queryParams?: Dict<unknown>;
    context?: Dict<unknown>;
    isResolved: boolean;
    constructor(name: string, handler?: IHandler);
    abstract getModel(transition: Transition): Promise<Dict<unknown> | undefined> | Dict<unknown>;
    abstract getUnresolved(): UnresolvedHandlerInfoByParam | UnresolvedHandlerInfoByObject;
    abstract getHandler: GetHandlerFunc;
    serialize(_context?: Dict<unknown>): Dict<unknown>;
    resolve(shouldContinue: Continuation, transition: Transition): Promise<ResolvedHandlerInfo>;
    becomeResolved(transition: Transition | null, resolvedContext: Dict<unknown>): ResolvedHandlerInfo;
    shouldSupercede(other?: HandlerInfo): boolean;
    handler: IHandler | undefined;
    handlerPromise: Promise<IHandler>;
    protected promiseLabel(label: string): string;
    protected log(transition: Transition, message: string): void;
    private updateHandler;
    private runBeforeModelHook;
    private runAfterModelHook;
    private checkForAbort;
    private stashResolvedModel;
    private fetchHandler;
    private _processHandler;
}
export declare class ResolvedHandlerInfo extends HandlerInfo {
    isResolved: boolean;
    constructor(name: string, handler: IHandler | undefined, params: Dict<unknown>, context?: Dict<unknown>);
    resolve(_shouldContinue?: Continuation, transition?: Transition): Promise<this>;
    getUnresolved(): UnresolvedHandlerInfoByParam;
    getHandler: (_name: string) => never;
    getModel(): never;
}
export declare class UnresolvedHandlerInfoByParam extends HandlerInfo {
    getHandler: GetHandlerFunc;
    params: Dict<unknown>;
    constructor(name: string, getHandler: GetHandlerFunc, params: Dict<unknown>, handler?: IHandler);
    getUnresolved(): this;
    getModel(transition: Transition): Promise<Dict<unknown> | undefined>;
}
export declare class UnresolvedHandlerInfoByObject extends HandlerInfo {
    names: string[];
    serializer?: SerializerFunc;
    getHandler: GetHandlerFunc;
    constructor(name: string, names: string[], getHandler: GetHandlerFunc, serializer: SerializerFunc, context: Dict<unknown>);
    getModel(transition: Transition): Promise<Dict<unknown> | undefined>;
    getUnresolved(): this;
    /**
      @private
  
      Serializes a handler using its custom `serialize` method or
      by a default that looks up the expected property name from
      the dynamic segment.
  
      @param {Object} model the model to be serialized for this handler
    */
    serialize(model?: IModel): any;
}
export {};
