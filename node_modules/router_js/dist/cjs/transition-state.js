'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransitionError = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _rsvp = require('rsvp');

var _utils = require('./utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TransitionState = function () {
    function TransitionState() {
        _classCallCheck(this, TransitionState);

        this.handlerInfos = [];
        this.queryParams = {};
        this.params = {};
    }

    _createClass(TransitionState, [{
        key: 'promiseLabel',
        value: function promiseLabel(label) {
            var targetName = '';
            (0, _utils.forEach)(this.handlerInfos, function (handlerInfo) {
                if (targetName !== '') {
                    targetName += '.';
                }
                targetName += handlerInfo.name;
                return true;
            });
            return (0, _utils.promiseLabel)("'" + targetName + "': " + label);
        }
    }, {
        key: 'resolve',
        value: function resolve(shouldContinue, transition) {
            // First, calculate params for this state. This is useful
            // information to provide to the various route hooks.
            var params = this.params;
            (0, _utils.forEach)(this.handlerInfos, function (handlerInfo) {
                params[handlerInfo.name] = handlerInfo.params || {};
                return true;
            });
            transition.resolveIndex = 0;
            var currentState = this;
            var wasAborted = false;
            // The prelude RSVP.resolve() asyncs us into the promise land.
            return _rsvp.Promise.resolve(null, this.promiseLabel('Start transition')).then(resolveOneHandlerInfo, null, this.promiseLabel('Resolve handler')).catch(handleError, this.promiseLabel('Handle error'));
            function innerShouldContinue() {
                return _rsvp.Promise.resolve(shouldContinue(), currentState.promiseLabel('Check if should continue')).catch(function (reason) {
                    // We distinguish between errors that occurred
                    // during resolution (e.g. before"Model/model/afterModel),
                    // and aborts due to a rejecting promise from shouldContinue().
                    wasAborted = true;
                    return _rsvp.Promise.reject(reason);
                }, currentState.promiseLabel('Handle abort'));
            }
            function handleError(error) {
                // This is the only possible
                // reject value of TransitionState#resolve
                var handlerInfos = currentState.handlerInfos;
                var errorHandlerIndex = transition.resolveIndex >= handlerInfos.length ? handlerInfos.length - 1 : transition.resolveIndex;
                return _rsvp.Promise.reject(new TransitionError(error, currentState.handlerInfos[errorHandlerIndex].handler, wasAborted, currentState));
            }
            function proceed(resolvedHandlerInfo) {
                var wasAlreadyResolved = currentState.handlerInfos[transition.resolveIndex].isResolved;
                // Swap the previously unresolved handlerInfo with
                // the resolved handlerInfo
                currentState.handlerInfos[transition.resolveIndex++] = resolvedHandlerInfo;
                if (!wasAlreadyResolved) {
                    // Call the redirect hook. The reason we call it here
                    // vs. afterModel is so that redirects into child
                    // routes don't re-run the model hooks for this
                    // already-resolved route.
                    var handler = resolvedHandlerInfo.handler;
                    if (handler !== undefined) {
                        if (handler._redirect) {
                            handler._redirect(resolvedHandlerInfo.context, transition);
                        } else if (handler.redirect) {
                            handler.redirect(resolvedHandlerInfo.context, transition);
                        }
                    }
                }
                // Proceed after ensuring that the redirect hook
                // didn't abort this transition by transitioning elsewhere.
                return innerShouldContinue().then(resolveOneHandlerInfo, null, currentState.promiseLabel('Resolve handler'));
            }
            function resolveOneHandlerInfo() {
                if (transition.resolveIndex === currentState.handlerInfos.length) {
                    // This is is the only possible
                    // fulfill value of TransitionState#resolve
                    return currentState;
                }
                var handlerInfo = currentState.handlerInfos[transition.resolveIndex];
                return handlerInfo.resolve(innerShouldContinue, transition).then(proceed, null, currentState.promiseLabel('Proceed'));
            }
        }
    }]);

    return TransitionState;
}();

exports.default = TransitionState;

var TransitionError = exports.TransitionError = function TransitionError(error, handler, wasAborted, state) {
    _classCallCheck(this, TransitionError);

    this.error = error;
    this.handler = handler;
    this.wasAborted = wasAborted;
    this.state = state;
};
//# sourceMappingURL=transition-state.js.map