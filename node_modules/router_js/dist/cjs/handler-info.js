'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UnresolvedHandlerInfoByObject = exports.UnresolvedHandlerInfoByParam = exports.ResolvedHandlerInfo = exports.DEFAULT_HANDLER = exports.noopGetHandler = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _rsvp = require('rsvp');

var _transition = require('./transition');

var _utils = require('./utils');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var stubHandler = {
    _handlerName: '',
    context: undefined,
    handler: '',
    names: []
};
var noopGetHandler = exports.noopGetHandler = function noopGetHandler() {
    return _rsvp.Promise.resolve(stubHandler);
};
var DEFAULT_HANDLER = exports.DEFAULT_HANDLER = Object.freeze({
    _handlerName: '',
    context: undefined,
    handler: '',
    names: []
});

var HandlerInfo = function () {
    function HandlerInfo(name, handler) {
        _classCallCheck(this, HandlerInfo);

        this.params = {};
        this.isResolved = false;
        // initialize local properties to ensure consistent object shape
        this._handler = DEFAULT_HANDLER;
        this._handlerPromise = undefined;
        this.name = name;
        if (handler) {
            this._processHandler(handler);
        }
    }

    _createClass(HandlerInfo, [{
        key: 'serialize',
        value: function serialize(_context) {
            return this.params || {};
        }
    }, {
        key: 'resolve',
        value: function resolve(shouldContinue, transition) {
            var _this = this;

            return _rsvp.Promise.resolve(this.handlerPromise, this.promiseLabel('Start handler')).then(function (handler) {
                return _this.checkForAbort(shouldContinue, handler);
            }, null, this.promiseLabel('Check for abort')).then(function () {
                return _this.runBeforeModelHook(transition);
            }, null, this.promiseLabel('Before model')).then(function () {
                return _this.checkForAbort(shouldContinue, null);
            }, null, this.promiseLabel("Check if aborted during 'beforeModel' hook")).then(function () {
                return _this.getModel(transition);
            }).then(function (resolvedModel) {
                return _this.checkForAbort(shouldContinue, resolvedModel);
            }, null, this.promiseLabel("Check if aborted in 'model' hook")).then(function (resolvedModel) {
                return _this.runAfterModelHook(transition, resolvedModel);
            }).then(function (resolvedModel) {
                return _this.becomeResolved(transition, resolvedModel);
            });
        }
    }, {
        key: 'becomeResolved',
        value: function becomeResolved(transition, resolvedContext) {
            var params = this.serialize(resolvedContext);
            if (transition) {
                this.stashResolvedModel(transition, resolvedContext);
                transition.params = transition.params || {};
                transition.params[this.name] = params;
            }
            var context = void 0;
            var contextsMatch = resolvedContext === this.context;
            if ('context' in this || !contextsMatch) {
                context = resolvedContext;
            }
            return new ResolvedHandlerInfo(this.name, this.handler, params, context);
        }
    }, {
        key: 'shouldSupercede',
        value: function shouldSupercede(other) {
            // Prefer this newer handlerInfo over `other` if:
            // 1) The other one doesn't exist
            // 2) The names don't match
            // 3) This handler has a context that doesn't match
            //    the other one (or the other one doesn't have one).
            // 4) This handler has parameters that don't match the other.
            if (!other) {
                return true;
            }
            var contextsMatch = other.context === this.context;
            return other.name !== this.name || 'context' in this && !contextsMatch || this.hasOwnProperty('params') && !paramsMatch(this.params, other.params);
        }
    }, {
        key: 'promiseLabel',
        value: function promiseLabel(label) {
            return (0, _utils.promiseLabel)("'" + this.name + "' " + label);
        }
    }, {
        key: 'log',
        value: function log(transition, message) {
            if (transition.log) {
                transition.log(this.name + ': ' + message);
            }
        }
    }, {
        key: 'updateHandler',
        value: function updateHandler(handler) {
            // Store the name of the handler on the handler for easy checks later
            handler._handlerName = this.name;
            return this.handler = handler;
        }
    }, {
        key: 'runBeforeModelHook',
        value: function runBeforeModelHook(transition) {
            if (transition.trigger) {
                transition.trigger(true, 'willResolveModel', transition, this.handler);
            }
            var result = void 0;
            if (this.handler) {
                if (this.handler._beforeModel !== undefined) {
                    result = this.handler._beforeModel(transition);
                } else if (this.handler.beforeModel !== undefined) {
                    result = this.handler.beforeModel(transition);
                }
            }
            if ((0, _transition.isTransition)(result)) {
                result = null;
            }
            return _rsvp.Promise.resolve(result);
        }
    }, {
        key: 'runAfterModelHook',
        value: function runAfterModelHook(transition, resolvedModel) {
            // Stash the resolved model on the payload.
            // This makes it possible for users to swap out
            // the resolved model in afterModel.
            var name = this.name;
            this.stashResolvedModel(transition, resolvedModel);
            var result = void 0;
            if (this.handler !== undefined) {
                if (this.handler._afterModel !== undefined) {
                    result = this.handler._afterModel(resolvedModel, transition);
                } else if (this.handler.afterModel !== undefined) {
                    result = this.handler.afterModel(resolvedModel, transition);
                }
            }
            result = (0, _transition.prepareResult)(result);
            return _rsvp.Promise.resolve(result).then(function () {
                // Ignore the fulfilled value returned from afterModel.
                // Return the value stashed in resolvedModels, which
                // might have been swapped out in afterModel.
                return transition.resolvedModels[name];
            });
        }
    }, {
        key: 'checkForAbort',
        value: function checkForAbort(shouldContinue, value) {
            return _rsvp.Promise.resolve(shouldContinue(), this.promiseLabel('Check for abort')).then(function () {
                // We don't care about shouldContinue's resolve value;
                // pass along the original value passed to this fn.
                return value;
            }, null, this.promiseLabel('Ignore fulfillment value and continue'));
        }
    }, {
        key: 'stashResolvedModel',
        value: function stashResolvedModel(transition, resolvedModel) {
            transition.resolvedModels = transition.resolvedModels || {};
            transition.resolvedModels[this.name] = resolvedModel;
        }
    }, {
        key: 'fetchHandler',
        value: function fetchHandler() {
            var handler = this.getHandler(this.name);
            return this._processHandler(handler);
        }
    }, {
        key: '_processHandler',
        value: function _processHandler(handler) {
            var _this2 = this;

            // Setup a handlerPromise so that we can wait for asynchronously loaded handlers
            this.handlerPromise = _rsvp.Promise.resolve(handler);
            // Wait until the 'handler' property has been updated when chaining to a handler
            // that is a promise
            if ((0, _utils.isPromise)(handler)) {
                this.handlerPromise = this.handlerPromise.then(function (h) {
                    return _this2.updateHandler(h);
                });
                // set to undefined to avoid recursive loop in the handler getter
                return this.handler = undefined;
            } else if (handler) {
                return this.updateHandler(handler);
            }
            return undefined;
        }
    }, {
        key: 'handler',
        get: function get() {
            // _handler could be set to either a handler object or undefined, so we
            // compare against a default reference to know when it's been set
            if (this._handler !== DEFAULT_HANDLER) {
                return this._handler;
            }
            return this.fetchHandler();
        },
        set: function set(handler) {
            this._handler = handler;
        }
    }, {
        key: 'handlerPromise',
        get: function get() {
            if (this._handlerPromise) {
                return this._handlerPromise;
            }
            this.fetchHandler();
            return this._handlerPromise;
        },
        set: function set(handlerPromise) {
            this._handlerPromise = handlerPromise;
        }
    }]);

    return HandlerInfo;
}();

exports.default = HandlerInfo;

var ResolvedHandlerInfo = exports.ResolvedHandlerInfo = function (_HandlerInfo) {
    _inherits(ResolvedHandlerInfo, _HandlerInfo);

    function ResolvedHandlerInfo(name, handler, params, context) {
        _classCallCheck(this, ResolvedHandlerInfo);

        var _this3 = _possibleConstructorReturn(this, (ResolvedHandlerInfo.__proto__ || Object.getPrototypeOf(ResolvedHandlerInfo)).call(this, name, handler));

        _this3.getHandler = function (_name) {
            throw new Error('Method not implemented.');
        };
        _this3.params = params;
        _this3.isResolved = true;
        _this3.context = context;
        return _this3;
    }

    _createClass(ResolvedHandlerInfo, [{
        key: 'resolve',
        value: function resolve(_shouldContinue, transition) {
            // A ResolvedHandlerInfo just resolved with itself.
            if (transition && transition.resolvedModels) {
                transition.resolvedModels[this.name] = this.context;
            }
            return _rsvp.Promise.resolve(this, this.promiseLabel('Resolve'));
        }
    }, {
        key: 'getUnresolved',
        value: function getUnresolved() {
            return new UnresolvedHandlerInfoByParam(this.name, noopGetHandler, this.params, this.handler);
        }
    }, {
        key: 'getModel',
        value: function getModel() {
            throw new Error('Method not implemented.');
        }
    }]);

    return ResolvedHandlerInfo;
}(HandlerInfo);

var UnresolvedHandlerInfoByParam = exports.UnresolvedHandlerInfoByParam = function (_HandlerInfo2) {
    _inherits(UnresolvedHandlerInfoByParam, _HandlerInfo2);

    function UnresolvedHandlerInfoByParam(name, getHandler, params, handler) {
        _classCallCheck(this, UnresolvedHandlerInfoByParam);

        var _this4 = _possibleConstructorReturn(this, (UnresolvedHandlerInfoByParam.__proto__ || Object.getPrototypeOf(UnresolvedHandlerInfoByParam)).call(this, name, handler));

        _this4.params = {};
        _this4.params = params;
        _this4.getHandler = getHandler;
        return _this4;
    }

    _createClass(UnresolvedHandlerInfoByParam, [{
        key: 'getUnresolved',
        value: function getUnresolved() {
            return this;
        }
    }, {
        key: 'getModel',
        value: function getModel(transition) {
            var fullParams = this.params;
            if (transition && transition.queryParams) {
                fullParams = {};
                (0, _utils.merge)(fullParams, this.params);
                fullParams.queryParams = transition.queryParams;
            }
            var handler = this.handler;
            var result = undefined;
            if (handler._deserialize) {
                result = handler._deserialize(fullParams, transition);
            } else if (handler.deserialize) {
                result = handler.deserialize(fullParams, transition);
            } else if (handler._model) {
                result = handler._model(fullParams, transition);
            } else if (handler.model) {
                result = handler.model(fullParams, transition);
            }
            if (result && (0, _transition.isTransition)(result)) {
                result = undefined;
            }
            return _rsvp.Promise.resolve(result, this.promiseLabel('Resolve value returned from one of the model hooks'));
        }
    }]);

    return UnresolvedHandlerInfoByParam;
}(HandlerInfo);

var UnresolvedHandlerInfoByObject = exports.UnresolvedHandlerInfoByObject = function (_HandlerInfo3) {
    _inherits(UnresolvedHandlerInfoByObject, _HandlerInfo3);

    function UnresolvedHandlerInfoByObject(name, names, getHandler, serializer, context) {
        _classCallCheck(this, UnresolvedHandlerInfoByObject);

        var _this5 = _possibleConstructorReturn(this, (UnresolvedHandlerInfoByObject.__proto__ || Object.getPrototypeOf(UnresolvedHandlerInfoByObject)).call(this, name));

        _this5.names = [];
        _this5.names = names;
        _this5.getHandler = getHandler;
        _this5.serializer = serializer;
        _this5.context = context;
        _this5.names = _this5.names || [];
        return _this5;
    }

    _createClass(UnresolvedHandlerInfoByObject, [{
        key: 'getModel',
        value: function getModel(transition) {
            this.log(transition, this.name + ': resolving provided model');
            return _rsvp.Promise.resolve(this.context);
        }
    }, {
        key: 'getUnresolved',
        value: function getUnresolved() {
            return this;
        }
        /**
          @private
             Serializes a handler using its custom `serialize` method or
          by a default that looks up the expected property name from
          the dynamic segment.
             @param {Object} model the model to be serialized for this handler
        */

    }, {
        key: 'serialize',
        value: function serialize(model) {
            var names = this.names,
                context = this.context;

            if (!model) {
                model = context;
            }
            var object = {};
            if ((0, _utils.isParam)(model)) {
                object[names[0]] = model;
                return object;
            }
            // Use custom serialize if it exists.
            if (this.serializer) {
                // invoke this.serializer unbound (getSerializer returns a stateless function)
                return this.serializer.call(null, model, names);
            } else if (this.handler) {
                if (this.handler._serialize) {
                    return this.handler._serialize(model, names);
                }
                if (this.handler.serialize) {
                    return this.handler.serialize(model, names);
                }
            }
            if (names.length !== 1) {
                return;
            }
            var name = names[0];
            if (/_id$/.test(name)) {
                object[name] = model.id;
            } else {
                object[name] = model;
            }
            return object;
        }
    }]);

    return UnresolvedHandlerInfoByObject;
}(HandlerInfo);

function paramsMatch(a, b) {
    if (!a !== !b) {
        // Only one is null.
        return false;
    }
    if (!a) {
        // Both must be null.
        return true;
    }
    // Note: this assumes that both params have the same
    // number of keys, but since we're comparing the
    // same handlers, they should.
    for (var k in a) {
        if (a.hasOwnProperty(k) && a[k] !== b[k]) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=handler-info.js.map