'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Transition = exports.TransitionAborted = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _transitionAbortedError = require('./transition-aborted-error');

Object.defineProperty(exports, 'TransitionAborted', {
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_transitionAbortedError).default;
    }
});
exports.logAbort = logAbort;
exports.isTransition = isTransition;
exports.prepareResult = prepareResult;

var _rsvp = require('rsvp');

var _transitionAbortedError2 = _interopRequireDefault(_transitionAbortedError);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
  A Transition is a thennable (a promise-like object) that represents
  an attempt to transition to another route. It can be aborted, either
  explicitly via `abort` or by attempting another transition while a
  previous one is still underway. An aborted transition can also
  be `retry()`d later.

  @class Transition
  @constructor
  @param {Object} router
  @param {Object} intent
  @param {Object} state
  @param {Object} error
  @private
 */
var Transition = function () {
    function Transition(router, intent, state) {
        var _this = this;

        var error = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
        var previousTransition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;

        _classCallCheck(this, Transition);

        this.isAborted = false;
        this.isActive = true;
        this.urlMethod = 'update';
        this.resolveIndex = 0;
        this.queryParamsOnly = false;
        this.isTransition = true;
        this.isCausedByAbortingTransition = false;
        this.isCausedByInitialTransition = false;
        this.isCausedByAbortingReplaceTransition = false;
        this._visibleQueryParams = {};
        this.state = state || router.state;
        this.intent = intent;
        this.router = router;
        this.data = intent && intent.data || {};
        this.resolvedModels = {};
        this.queryParams = {};
        this.promise = undefined;
        this.error = undefined;
        this.params = {};
        this.handlerInfos = [];
        this.targetName = undefined;
        this.pivotHandler = undefined;
        this.sequence = -1;
        if (error) {
            this.promise = _rsvp.Promise.reject(error);
            this.error = error;
            return;
        }
        // if you're doing multiple redirects, need the new transition to know if it
        // is actually part of the first transition or not. Any further redirects
        // in the initial transition also need to know if they are part of the
        // initial transition
        this.isCausedByAbortingTransition = !!previousTransition;
        this.isCausedByInitialTransition = !!previousTransition && (previousTransition.isCausedByInitialTransition || previousTransition.sequence === 0);
        // Every transition in the chain is a replace
        this.isCausedByAbortingReplaceTransition = !!previousTransition && previousTransition.urlMethod === 'replace' && (!previousTransition.isCausedByAbortingTransition || previousTransition.isCausedByAbortingReplaceTransition);
        if (state) {
            this.params = state.params;
            this.queryParams = state.queryParams;
            this.handlerInfos = state.handlerInfos;
            var len = state.handlerInfos.length;
            if (len) {
                this.targetName = state.handlerInfos[len - 1].name;
            }
            for (var i = 0; i < len; ++i) {
                var handlerInfo = state.handlerInfos[i];
                // TODO: this all seems hacky
                if (!handlerInfo.isResolved) {
                    break;
                }
                this.pivotHandler = handlerInfo.handler;
            }
            this.sequence = router.currentSequence++;
            this.promise = state.resolve(function () {
                if (_this.isAborted) {
                    return _rsvp.Promise.reject(false, (0, _utils.promiseLabel)('Transition aborted - reject'));
                }
                return _rsvp.Promise.resolve(true);
            }, this).catch(function (result) {
                if (result.wasAborted || _this.isAborted) {
                    return _rsvp.Promise.reject(logAbort(_this));
                } else {
                    _this.trigger(false, 'error', result.error, _this, result.handler);
                    _this.abort();
                    return _rsvp.Promise.reject(result.error);
                }
            }, (0, _utils.promiseLabel)('Handle Abort'));
        } else {
            this.promise = _rsvp.Promise.resolve(this.state);
            this.params = {};
        }
    }
    // Todo Delete?


    _createClass(Transition, [{
        key: 'isExiting',
        value: function isExiting(handler) {
            var handlerInfos = this.handlerInfos;
            for (var i = 0, len = handlerInfos.length; i < len; ++i) {
                var handlerInfo = handlerInfos[i];
                if (handlerInfo.name === handler || handlerInfo.handler === handler) {
                    return false;
                }
            }
            return true;
        }
        /**
          The Transition's internal promise. Calling `.then` on this property
          is that same as calling `.then` on the Transition object itself, but
          this property is exposed for when you want to pass around a
          Transition's promise, but not the Transition object itself, since
          Transition object can be externally `abort`ed, while the promise
          cannot.
             @property promise
          @type {Object}
          @public
         */
        /**
          Custom state can be stored on a Transition's `data` object.
          This can be useful for decorating a Transition within an earlier
          hook and shared with a later hook. Properties set on `data` will
          be copied to new transitions generated by calling `retry` on this
          transition.
             @property data
          @type {Object}
          @public
         */
        /**
          A standard promise hook that resolves if the transition
          succeeds and rejects if it fails/redirects/aborts.
             Forwards to the internal `promise` property which you can
          use in situations where you want to pass around a thennable,
          but not the Transition itself.
             @method then
          @param {Function} onFulfilled
          @param {Function} onRejected
          @param {String} label optional string for labeling the promise.
          Useful for tooling.
          @return {Promise}
          @public
         */

    }, {
        key: 'then',
        value: function then(onFulfilled, onRejected, label) {
            return this.promise.then(onFulfilled, onRejected, label);
        }
        /**
             Forwards to the internal `promise` property which you can
          use in situations where you want to pass around a thennable,
          but not the Transition itself.
             @method catch
          @param {Function} onRejection
          @param {String} label optional string for labeling the promise.
          Useful for tooling.
          @return {Promise}
          @public
         */

    }, {
        key: 'catch',
        value: function _catch(onRejection, label) {
            return this.promise.catch(onRejection, label);
        }
        /**
             Forwards to the internal `promise` property which you can
          use in situations where you want to pass around a thennable,
          but not the Transition itself.
             @method finally
          @param {Function} callback
          @param {String} label optional string for labeling the promise.
          Useful for tooling.
          @return {Promise}
          @public
         */

    }, {
        key: 'finally',
        value: function _finally(callback, label) {
            return this.promise.finally(callback, label);
        }
        /**
          Aborts the Transition. Note you can also implicitly abort a transition
          by initiating another transition while a previous one is underway.
             @method abort
          @return {Transition} this transition
          @public
         */

    }, {
        key: 'abort',
        value: function abort() {
            if (this.isAborted) {
                return this;
            }
            (0, _utils.log)(this.router, this.sequence, this.targetName + ': transition was aborted');
            this.intent.preTransitionState = this.router.state;
            this.isAborted = true;
            this.isActive = false;
            this.router.activeTransition = undefined;
            return this;
        }
        /**
             Retries a previously-aborted transition (making sure to abort the
          transition if it's still active). Returns a new transition that
          represents the new attempt to transition.
             @method retry
          @return {Transition} new transition
          @public
         */

    }, {
        key: 'retry',
        value: function retry() {
            // TODO: add tests for merged state retry()s
            this.abort();
            var newTransition = this.router.transitionByIntent(this.intent, false);
            // inheriting a `null` urlMethod is not valid
            // the urlMethod is only set to `null` when
            // the transition is initiated *after* the url
            // has been updated (i.e. `router.handleURL`)
            //
            // in that scenario, the url method cannot be
            // inherited for a new transition because then
            // the url would not update even though it should
            if (this.urlMethod !== null) {
                newTransition.method(this.urlMethod);
            }
            return newTransition;
        }
        /**
             Sets the URL-changing method to be employed at the end of a
          successful transition. By default, a new Transition will just
          use `updateURL`, but passing 'replace' to this method will
          cause the URL to update using 'replaceWith' instead. Omitting
          a parameter will disable the URL change, allowing for transitions
          that don't update the URL at completion (this is also used for
          handleURL, since the URL has already changed before the
          transition took place).
             @method method
          @param {String} method the type of URL-changing method to use
            at the end of a transition. Accepted values are 'replace',
            falsy values, or any other non-falsy value (which is
            interpreted as an updateURL transition).
             @return {Transition} this transition
          @public
         */

    }, {
        key: 'method',
        value: function method(_method) {
            this.urlMethod = _method;
            return this;
        }
        // Alias 'trigger' as 'send'

    }, {
        key: 'send',
        value: function send(ignoreFailure, _name, err, transition, handler) {
            this.trigger(ignoreFailure, _name, err, transition, handler);
        }
        /**
             Fires an event on the current list of resolved/resolving
          handlers within this transition. Useful for firing events
          on route hierarchies that haven't fully been entered yet.
             Note: This method is also aliased as `send`
             @method trigger
          @param {Boolean} [ignoreFailure=false] a boolean specifying whether unhandled events throw an error
          @param {String} name the name of the event to fire
          @public
         */

    }, {
        key: 'trigger',
        value: function trigger(ignoreFailure, _name) {
            for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }

            _utils.trigger.apply(undefined, [this.router, this.state.handlerInfos.slice(0, this.resolveIndex + 1), ignoreFailure, _name].concat(args));
        }
        /**
          Transitions are aborted and their promises rejected
          when redirects occur; this method returns a promise
          that will follow any redirects that occur and fulfill
          with the value fulfilled by any redirecting transitions
          that occur.
             @method followRedirects
          @return {Promise} a promise that fulfills with the same
            value that the final redirecting transition fulfills with
          @public
         */

    }, {
        key: 'followRedirects',
        value: function followRedirects() {
            var router = this.router;
            return this.promise.catch(function (reason) {
                if (router.activeTransition) {
                    return router.activeTransition.followRedirects();
                }
                return _rsvp.Promise.reject(reason);
            });
        }
    }, {
        key: 'toString',
        value: function toString() {
            return 'Transition (sequence ' + this.sequence + ')';
        }
        /**
          @private
         */

    }, {
        key: 'log',
        value: function log(message) {
            (0, _utils.log)(this.router, this.sequence, message);
        }
    }]);

    return Transition;
}();
/**
  @private

  Logs and returns an instance of TransitionAborted.
 */


exports.Transition = Transition;
function logAbort(transition) {
    (0, _utils.log)(transition.router, transition.sequence, 'detected abort.');
    return new _transitionAbortedError2.default();
}
function isTransition(obj) {
    return typeof obj === 'object' && obj instanceof Transition && obj.isTransition;
}
function prepareResult(obj) {
    if (isTransition(obj)) {
        return null;
    }
    return obj;
}
//# sourceMappingURL=transition.js.map